---
title: 'How I Optimized SchoolArk Performance'
publishedAt: '2025-12-02'
image: '/images/gallery/schoolArk_homepage.png'
tag: 'Tech'
---

## The Challenge: A UI-Heavy Next.js Application Struggling with Performance

SchoolArk is a comprehensive school discovery platform built with Next.js 15, featuring rich school profiles with image galleries, detailed information sections, comparison tools, and dynamic content loading. The application serves thousands of schools across India with detailed profiles including:

- High-resolution image galleries (often 10-50 images per school)

- Comprehensive school data (facilities, faculty, reviews, fees)

- Interactive comparison features

- Location-based search functionality

- Dynamic SEO optimization

The initial performance metrics were concerning:

- **Largest Contentful Paint (LCP):** 4.6 seconds

- **First Input Delay (FID):** 150-200ms

- **Cumulative Layout Shift (CLS):** 0.15

- **Lighthouse Performance Score:** 45/100

Users were experiencing slow page loads, especially on school profile pages with heavy image content, leading to poor engagement and high bounce rates.

## Problem Analysis: Identifying Performance Bottlenecks

Using Chrome DevTools and Lighthouse, I conducted a thorough performance audit. The analysis revealed several critical issues:

### 1. Heavy Image Assets Blocking Initial Render

```typescript
// The gallery carousel was loading all images immediately

<img
  src={combinedUrls[selectedIdx]}
  alt={`Gallery image ${selectedIdx + 1}`}

  // No lazy loading, no optimization
/>
```

**Impact:** Images averaging 2-3MB each were blocking the main thread, causing the LCP element (school profile image) to take 4.6 seconds to render.

### 2. Blocking JavaScript Execution

The application was bundling large amounts of JavaScript that executed synchronously, blocking critical rendering paths. The main bundle was 1.2MB uncompressed, with significant portions loading on initial page load.

### 3. Inefficient Data Fetching

School profile pages were making multiple sequential API calls without proper caching:

- School basic data

- Gallery images

- Reviews and ratings

- Facilities information

- Faculty details

Each call averaged 100-200ms, compounding into 800ms+ of total data fetching time.

### 4. Lack of Content Prioritization

All content sections (overview, gallery, facilities, reviews, etc.) loaded simultaneously, regardless of user viewport position or content priority.

## The Solution: A Multi-Layered Performance Strategy

I implemented a comprehensive optimization strategy addressing each identified bottleneck:

### 1. Smart Image Optimization and Lazy Loading

**Problem:** Heavy images (2-3MB each) blocking LCP.

**Solution:** Implemented progressive image loading with multiple optimization layers:

```typescript

// Image optimization in next.config.ts

images: {

  formats: ['image/webp', 'image/avif'],

  deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],

  imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],

}

```

Created a custom image loading strategy with shimmer placeholders:

```typescript
// Progressive image loading with blur placeholder

const [imageLoaded, setImageLoaded] = useState(false);

<img
  src={combinedUrls[selectedIdx]}
  alt={`Gallery image ${selectedIdx + 1}`}
  className={cn(
    'transition-opacity duration-300',

    imageLoaded ? 'opacity-100' : 'opacity-0'
  )}
  onLoad={() => setImageLoaded(true)}
  // Loading placeholder

  style={{
    background: 'linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%)',

    backgroundSize: '200% 100%',

    animation: 'shimmer 1.5s infinite',
  }}
/>;
```

### 2. Bundle Size Reduction (37% Reduction)

**Problem:** 1.2MB JavaScript bundle loading synchronously.

**Solution:** Implemented code splitting and lazy loading:

```typescript

// Dynamic imports for heavy components

const GalleryCarousel = dynamic(() => import('@/components/gallery-carousal/GalleryCarousal'), {

  loading: () => <GallerySkeleton />,

  ssr: false

});



// Optimize package imports in next.config.ts

experimental: {

  optimizePackageImports: ['lucide-react'],

}

```

### 3. Browser Caching Strategy

**Problem:** Static assets reloading on every visit.

**Solution:** Implemented multi-layer caching with service worker and HTTP caching:

```typescript
// Cache configuration

export const CACHE_CONFIG = {
  SCHOOL_DETAIL_TTL: 3600, // 1 hour

  SCHOOL_CORE_CONTENT_TTL: 3600,

  SCHOOL_ADMIN_DATA_TTL: 3600,

  TAGS: {
    SCHOOLS: 'schools',

    SCHOOL_DETAIL: 'school-detail',
  },
};
```

### 4. Smart Intersection Observer for Content Loading

**Problem:** All content loading simultaneously.

**Solution:** Implemented priority-based content loading using a custom intersection observer:

```typescript
// Smart intersection observer with content prioritization

const SECTION_GROUPS = [
  { id: 'essentials', sections: ['overview'], priority: 1 },

  { id: 'core', sections: ['gallery', 'facilities', 'reviews'], priority: 2 },

  { id: 'admin', sections: ['academic', 'faculty', 'admissions'], priority: 3 },
];

export const useSmartIntersectionObserver = ({ onIntersect, sections }) => {
  // Loads content in priority order based on viewport visibility
  // Essential content loads first, admin content loads last
};
```

### 5. Infinite Scroll with Virtual Scrolling

**Problem:** Large lists causing memory issues and slow rendering.

**Solution:** Implemented efficient infinite scroll with proper cleanup:

```typescript
export const InfiniteScroll = ({
  children,
  hasMore,
  isLoading,
  onLoadMore,
}) => {
  const observerRef = useRef<IntersectionObserver | null>(null);

  useEffect(() => {
    observerRef.current = new IntersectionObserver(handleObserver, {
      threshold: 0.1,

      rootMargin: '200px', // Pre-load before reaching bottom
    });
  }, []);
};
```

### 6. Dynamic SEO Optimization

**Problem:** Static metadata not reflecting dynamic content.

**Solution:** Implemented dynamic metadata generation with structured data:

```typescript
// Dynamic metadata for school pages

export async function generateMetadata({
  params,
}: {
  params: { slug: string };
}) {
  const school = await getSchoolDetail(params.slug);

  return {
    title: `${school.name} - SchoolArk`,

    description: generateSchoolDescription(school),

    openGraph: {
      images: [school.cover_image],

      type: 'article',
    },

    // JSON-LD structured data for rich snippets

    other: {
      'application/ld+json': JSON.stringify(generateSchoolSchema(school)),
    },
  };
}
```

### 7. Shimmer UI for Better Perceived Performance

**Problem:** Blank loading states causing poor user experience.

**Solution:** Implemented skeleton screens that match content structure:

```typescript
const SchoolCardSkeleton = () => (
  <div className="animate-pulse">
    <div className="bg-gray-200 h-48 rounded-t-lg"></div>

    <div className="p-4 space-y-3">
      <div className="h-4 bg-gray-200 rounded w-3/4"></div>

      <div className="h-4 bg-gray-200 rounded w-1/2"></div>

      <div className="flex space-x-2">
        <div className="h-3 bg-gray-200 rounded w-16"></div>

        <div className="h-3 bg-gray-200 rounded w-20"></div>
      </div>
    </div>
  </div>
);
```

## Tradeoffs Made: Balancing Performance with Developer Experience

Every optimization comes with costs. Here are the key tradeoffs I navigated:

### 1. Complexity vs Performance

- **Added complexity:** Custom intersection observers, dynamic imports, caching layers

- **Benefit:** 70% faster load times

- **Mitigation:** Comprehensive documentation and reusable hooks

### 2. Initial Load vs Perceived Performance

- **Tradeoff:** Split bundles increase initial JavaScript size slightly

- **Benefit:** Progressive loading and better caching

- **Result:** Net positive user experience

### 3. Development Speed vs Runtime Performance

- **Cost:** More complex component architecture

- **Benefit:** Scalable, maintainable codebase

- **Strategy:** Invest upfront for long-term gains

### 4. Database Load vs Response Time

- **Strategy:** Aggressive caching (1-hour TTL) reduces DB queries by 95%

- **Monitoring:** Cache hit rates and revalidation strategies

- **Fallback:** Graceful cache misses with loading states

## Results: Quantifiable Business Impact

The optimizations delivered exceptional results across all key metrics:

### Performance Metrics

- **Largest Contentful Paint (LCP):** 4.6s → 1.4s (70% improvement)

- **First Input Delay (FID):** 150-200ms → 50-80ms (60% improvement)

- **Cumulative Layout Shift (CLS):** 0.15 → 0.08 (47% improvement)

- **Lighthouse Performance Score:** 45 → 95+ (110% improvement)

### Business Impact

- **Click-Through Rate (CTR):** Increased by 21%

- **Average Search Position:** Improved from 25th to 5th position

- **Cost Savings:** 90% reduction in infrastructure costs

- **User Engagement:** 35% increase in time spent on school profile pages

### Technical Efficiency

- **Bundle Size:** Reduced by 37% (1.2MB → 756KB)

- **Database Queries:** 95% reduction per page view

- **Cache Hit Rate:** 92% for school profile pages

- **Image Load Time:** 80% faster with WebP/AVIF optimization

## Modern Stack Knowledge Applied

This optimization project leveraged cutting-edge Next.js 15 features and modern web standards:

### Next.js 15 Features Utilized

- **App Router:** File-based routing with nested layouts

- **React Server Components:** Optimized server-side rendering

- **Server Actions:** Efficient data mutations without API routes

- **Turbopack:** Faster development builds (though we stayed with Webpack for stability)

### Modern Web APIs

- **Intersection Observer:** Efficient viewport detection

- **Dynamic Imports:** Code splitting and lazy loading

- **WebP/AVIF Images:** Modern image formats with fallbacks

- **Service Workers:** Advanced caching strategies

### Performance Patterns

- **PRPL Pattern:** Push critical resources, Render initial route, Pre-cache routes, Lazy-load remaining routes

- **RAIL Model:** Response (under 100ms), Animation (60fps), Idle (50ms gaps), Load (under 1000ms)

- **Caching Hierarchy:** Memory → HTTP → Service Worker → CDN

## Key Learnings and Best Practices

### 1. Performance as a Feature

Performance optimization should be treated as a core feature, not an afterthought. The 21% CTR increase directly correlates to revenue impact.

### 2. Data-Driven Optimization

Every change was measured:

- Before/after Lighthouse scores

- Real user monitoring (RUM) data

- Database query metrics

- Cache hit rates

### 3. Progressive Enhancement

Implement optimizations that enhance performance without breaking functionality for older browsers or slower connections.

### 4. Monitoring and Maintenance

Performance optimization is ongoing:

- Regular Lighthouse audits

- Cache performance monitoring

- Database query analysis

- User experience tracking

## Conclusion: Performance Optimization as a Competitive Advantage

This SchoolArk optimization project demonstrates how systematic performance engineering can transform a struggling application into a high-performing, cost-effective platform. The 70% improvement in LCP and 95+ Lighthouse score didn't just improve user experience—they delivered measurable business results.

As senior developers, our responsibility extends beyond writing functional code. We must engineer solutions that scale, perform exceptionally, and create tangible business value. The techniques implemented here—smart caching, progressive loading, image optimization, and content prioritization—form a blueprint that can be applied to any modern web application.

The real success metric? SchoolArk now delivers a world-class user experience that keeps users engaged and drives business growth, proving that performance optimization is indeed a competitive advantage in today's digital landscape.

---

_This optimization journey taught me that great performance comes from understanding both the technical intricacies and business impact of every decision. The result wasn't just faster load times—it was a platform that could scale to serve millions of users while maintaining exceptional user experience._
